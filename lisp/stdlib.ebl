;;;
;;; A small standard library
;;;
;;; All of the recursively defined standard functions are tail recursive, so
;;; that they can be used on large inputs. This may have some impact on runtime
;;; speed (e.g. map needs to reverse its result), but not on the overall
;;; asymptotic bound. In fact, the recur keyword is so significantly faster than
;;; normal recursion, that the overhead of reversing a list more-or-less evens
;;; out. So the main difference is mostly in memory usage.
;;;


(namespace std
  (defn dolist (f lat)
    "[proc list] -> null, apply f to list for the side-effects"
    (if (null? lat)
        null
        (begin
          (f (car lat))
          (recur f (cdr lat)))))

  (def line-feed (character 10))

  (def reverse
       (let ((reverse-helper
              (lambda (lat result)
                (if (null? lat)
                    result
                    (recur (cdr lat) (cons (car lat) result))))))
         (lambda (lat)
           "[list] -> reversed list"
           (reverse-helper lat null))))

  (def map
       (let ((impl
              (lambda (f lat result)
                (if (null? lat)
                    (reverse result)
                    (recur f (cdr lat) (cons (f (car lat)) result))))))
         (lambda (f lat)
           "[f list] -> list, from applying f to each element of input list"
           (impl f lat null))))

  (def filter
       (let ((impl
              (lambda (pred lat result)
                (if (null? lat)
                    result
                    (if (pred (car lat))
                        (recur pred (cdr lat) (cons (car lat) result))
                        (recur pred (cdr lat) result))))))
         (lambda (pred lat)
           "[pred list] -> list of all elements of list that satisfy pred"
           (reverse (impl pred lat null)))))

  (def reduce
       (let ((impl
              (lambda (f lat result)
                (if (null? lat)
                    result
                    (recur f (cdr lat) (f result (car lat)))))))
         (lambda (f lat)
           "[f list] -> reduction of list by left fold with f"
           (impl f (cdr lat) (car lat)))))

  (defn zip (f lat1 lat2)
    "[f list1 list2] -> element-wise combination of list1 and list2"
    (if (null? lat1)
        null
        (cons
         (f (car lat1) (car lat2))
         (zip f (cdr lat1) (cdr lat2)))))

  (defn some (pred lat)
    "[pred list] -> first list element that satisfies pred, otherwise false"
    (if (null? lat)
        false
        (if (pred (car lat))
            (car lat)
            (recur pred (cdr lat)))))

  (defn every (pred lat)
    "[pred list] -> true if pred is true for all elements, otherwise false"
    (if (null? lat)
        true
        (if (not (pred (car lat)))
            false
            (recur pred (cdr lat)))))

  (defn assoc (lat key)
    "[key list] -> element associated with key in list, otherwise false"
    (some (lambda (elem)
            (equal? (car elem) key))
          lat))

  (defn identity (x) "[x] -> x" x)

  (def append
       (let ((append-impl
              (lambda (from to)
                (if (null? from)
                    to
                    (recur (cdr from) (cons (car from) to))))))
         (lambda (l1 l2)
           "[l1 l2] -> l2 appended to l1"
           (append-impl (reverse l1) l2))))

  (defn substr (str first last)
    "[str begin end] -> substring from [begin, end)"
    (apply string
           ((lambda (index lat)
              (if (equal? index first)
                  lat
                  (begin
                    (def next (- index 1))
                    (recur next (cons (string-ref str next) lat)))))
            last null)))

  ;; FIXME! Tokenizing negative numbers is broken right now, because '-', with
  ;; nothing after it, has to also be a valid lvalue.
  (def -1 (- 0 1))

  (defn split (str delim)
    "[str delim] -> list of substrings, by cleaving str at delim"
    ((lambda (index partial result)
       (if (equal? index -1)
           (if partial
               (cons (apply string partial) result)
               result)
           (let ((current (string-ref str index)))
             (if (equal? current delim)
                 (recur (- index 1) null (cons (apply string partial) result))
                 (recur (- index 1) (cons current partial) result)))))
     (- (length str) 1) null null))

  (defn join (lat delim)
    "[lat delim] -> string, by concatenating each elem in lat, with delim in between"
    ((lambda (lat result)
       (if (null? lat)
           result
           (recur (cdr lat)
                  (if result
                      (string result delim (car lat))
                      (string (car lat))))))
     lat false)))


(namespace fs
  (defn map-lines (f file-name)
    "[f file-name] -> result similar to std::map, but for lines of a file"
    (open file-name "r"
          (lambda (file)
            ((lambda (result)
               (def line (getline file))
               (if (not line)
                   (std::reverse result)
                   (recur (cons (f line) result))))
             null)))))
